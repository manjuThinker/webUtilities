@Scheduled(fixedRate = 10000)
    @Async
    @Transactional
    public void fetchPendingRecords() {
        List<Record> pendingRecords = entityManager
                .createQuery("SELECT r FROM Record r WHERE r.status = :status", Record.class)
                .setParameter("status", "PENDING")
                .getResultList();

        if (!pendingRecords.isEmpty()) {
            eventPublisher.publishEvent(new PendingRecordsEvent(this, pendingRecords));
        }
    }
}

// Event class
public static class PendingRecordsEvent {
    private final Object source;
    private final List<Record> records;

    public PendingRecordsEvent(Object source, List<Record> records) {
        this.source = source;
        this.records = records;
    }

    public List<Record> getRecords() {
        return records;
    }
}

// Event listener
@Service
public static class RecordProcessor {

    @PersistenceContext
    private EntityManager entityManager;

    @EventListener
    @Async
    @Transactional
    public void handlePendingRecords(PendingRecordsEvent event) {
        List<Record> records = event.getRecords();
        System.out.println("Processing records via event on thread: " + Thread.currentThread().getName());
        for (Record record : records) {
            record.setStatus("PROCESSED");
            entityManager.merge(record);
        }
        entityManager.flush();
    }
}
